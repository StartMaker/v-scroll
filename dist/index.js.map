{"version":3,"sources":["webpack://virtual-block/webpack/universalModuleDefinition","webpack://virtual-block/webpack/bootstrap","webpack://virtual-block/src/VirtualBlock.vue","webpack://virtual-block/./node_modules/vue-loader/lib/runtime/component-normalizer.js","webpack://virtual-block/./src/VirtualBlock.vue?98bf","webpack://virtual-block/./src/VirtualBlock.vue","webpack://virtual-block/./src/index.js"],"names":["plugin","install","Vue","options","component"],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD,O;ACVA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAK;AACL;AACA;;AAEA;AACA;AACA,yDAAiD,cAAc;AAC/D;;AAEA;AACA;AACA;AACA,mCAA2B,0BAA0B,EAAE;AACvD,yCAAiC,eAAe;AAChD;AACA;AACA;;AAEA;AACA,8DAAsD,+DAA+D;;AAErH;AACA;;;AAGA;AACA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACnDA;;;;AAGA;AACA;AACA;;kBAEA;sBAEA;AAHA;;kBAMA;AAFA;;kBAKA;AAFA;;kBAIA;qBAIA;AALA;AAdA;;0BAoBA;;2BAEA;8BACA;uBACA;uBACA;wBACA;6BAEA;AAPA;AAQA;;;;;AAGA;;4CACA;AACA;4BACA;yBACA,sBACA;AACA;AACA;mDACA;8BACA;AAEA;AACA;AACA;4BAEA;AAhBA;;AAiBA;;wBACA;uDACA;mBACA;0DACA;AACA;AACA;6CACA;iBACA,sBACA;AACA;AACA;4CACA;uBACA;AAEA;AACA;sDACA;AACA;iBACA;AAEA;AAvCA;gCAwCA;2BACA;AACA;mDACA;AACA;AACA;gCACA;2BACA;AACA;6CACA;AACA;AACA;sBACA;AACA;oCACA;2BACA;sDACA;AACA;AACA;;;wEAEA;AACA;AACA;AACA;4FACA;0EACA;0BACA;uBACA,wBACA;sCACA;4BACA;AAEA;uCACA;AACA;AACA;;AACA;;AACA;+EACA;AACA;mBACA,kCACA;gCACA;AAEA;AACA;wEACA;AACA;AACA;qBACA;kCACA;gBACA;6BACA;AACA;qCACA;kCACA;mCACA;AACA;+BACA;2BACA;mCACA;AACA;yCACA;8CACA;8CACA;mCACA;+BACA;AACA;uCACA;AACA;2BACA;AACA;AACA;gCACA;AACA;uBACA;AACA;AACA;2BACA;AACA;AACA;AACA;wEACA;AACA;AACA;qBACA;kCACA;gBACA;6BACA;qCACA;kCACA;iCACA;8CACA;mCACA;+BACA;AACA;uCACA;AACA;2BACA;AACA;AACA;gCACA;AACA;yCACA;gDACA;AACA;4CACA;2BACA;mCACA;AACA;uBACA;AACA;AACA;2BACA;AACA;AACA;AACA;6FACA;AACA;AACA;0EACA;oDACA;kEACA;AACA;6FACA;AACA;AACA;0EACA;wDACA;qFACA;AACA;uFACA;uBACA;8BACA,2DACA,mDACA;8BACA,2DACA,mDAEA;;yEACA;AACA;2CACA;4EACA;uBACA;0EACA;AACA;AACA;2CACA;gGACA;uBACA;iGACA;AACA;AACA;8CACA;mBACA;iCACA;iCACA;uBACA;AACA;AACA;+CACA;AACA;2EACA;iCACA;2CACA;yHACA;AAEA;AArJA;;kDAuJA;AACA,iEACA,mDAEA;AAEA;AAPA;AAhPA,E;;;;;;;;;;;;;ACjBA;AAAA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,yBAAyB;AACzB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,qBAAqB;AACrB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;;;;;;;;;;;;;;ACpGA;AAAA,0BAA0B,aAAa,0BAA0B,wBAAwB,wBAAwB,oCAAoC,kBAAkB,IAAI,yBAAyB,aAAa,QAAQ,+BAA+B,EAAE,qDAAqD,iBAAiB,6BAA6B,6EAA6E,EAAE,yBAAyB,UAAU,MAAM,wBAAwB,QAAQ,+BAA+B,EAAE;AACthB;;;;;;;;;;;;;;;;;;ACDA;AAAA;AACA;AACA;AACA;AACiP;AACjP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;;;;;;;;;;;;;ACxBA;;;;;;AAEA,IAAMA,SAAS;AACXC,WADW,mBACHC,GADG,EACEC,OADF,EACW;AAClBD,YAAIE,SAAJ,CAAc,cAAd;AACH;AAHU,CAAf;;kBAMeJ,M","file":"index.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine([], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"virtual-block\"] = factory();\n\telse\n\t\troot[\"virtual-block\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, {\n \t\t\t\tconfigurable: false,\n \t\t\t\tenumerable: true,\n \t\t\t\tget: getter\n \t\t\t});\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/dist/\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"./src/index.js\");\n","<template>\n    <div v-on=\"pageMode ? {} : {scroll: handleScroll}\" :style=\"containerStyle\" ref=\"vb\">\n        <div :style=\"{height: `${offsetTop}px`}\">\n        </div>\n        <div v-for=\"item in renderList\" \n             :style=\"{height: `${fixedBlockHeight ? fixedBlockHeight : item.height}px`}\" \n             :key=\"`${item.id}`\">\n            <slot :data=\"item\">\n            </slot>\n        </div>\n        <div :style=\"{height: `${offsetBot}px`}\">\n        </div>\n    </div>\n</template>\n\n<script>\nexport default {\n    props: {\n        // data is required\n        // height is required if pageMode is set to false\n        // when fixedBlockHeight is specified, the height key in data will be ignored\n        data: {\n            type: Array,\n            required: true\n        },\n        height: {\n            type: Number\n        },\n        fixedBlockHeight: {\n            type: Number\n        },\n        pageMode: {\n            type: Boolean,\n            default: true\n        }\n    },\n\n    data() {\n        return {\n            viewportBegin: 0,\n            viewportEnd: this.height,\n            offsetTop: 0,\n            offsetBot: 0,\n            renderList: [],\n            transformedData: []\n        }\n    },\n    watch: {\n        data: {\n            handler: function(newVal, oldVal) {\n                this.computeTransformedData(newVal);\n                // code blow used to update view when data changed\n                if (oldVal) {\n                    this.$nextTick(\n                        () => {\n                            // reset the scrollTop for container\n                            // update view by handleScroll()\n                            this.$refs.vb.scrollTop = 0;\n                            this.handleScroll();\n                        }\n                    );\n                }\n            },\n            immediate: true // when not in page mode, initailize data here\n        },\n        pageMode(newVal) {\n            if (newVal) {\n                window.addEventListener('scroll', this.handleScroll);\n            } else {\n                window.removeEventListener('scroll', this.handleScroll);\n            }\n            // recompute transformed data when pageMode changed\n            this.computeTransformedData(this.data);\n            this.$nextTick(\n                () => {\n                    // reset the scrollTop for container\n                    // update view by handleScroll()\n                    this.$refs.vb.scrollTop = 0;\n                    this.handleScroll()\n                }\n            );\n        },\n        fixedBlockHeight() {\n            // update view when fixedBlockHeight changed\n            this.handleScroll();\n        }\n    },\n    created() {\n        if (this.pageMode) {\n            // add scroll onto window\n            window.addEventListener('scroll', this.handleScroll);\n        }\n    },\n    mounted() {\n        if (this.pageMode) {\n            // in page mode, initialize transformed data here\n            this.computeTransformedData(this.data);\n        }\n        // initialize view by calling updateVb\n        this.updateVb(0);\n    },\n    destroyed() {\n        if (this.pageMode) {\n            window.removeEventListener('scroll', this.handleScroll);\n        }\n    },\n    methods: {\n        computeTransformedData(oriArr) {\n            // compute accumulative height value for each block\n            // note the function related to the variable 'pageMode'\n            // and when fixedRowHeight is specified, transformedData is not needed\n            if (!this.fixedRowHeight && ((this.pageMode && this.$refs.vb) || !this.pageMode)) {\n                let curHeight = this.pageMode ? this.$refs.vb.offsetTop : 0;\n                let rt = [curHeight];\n                oriArr.forEach(\n                    item => {\n                        curHeight += item.height;\n                        rt.push(curHeight);\n                    }\n                );\n                this.transformedData = rt;\n            }\n        },\n        handleScroll() {\n            // scrollTop is relative to the varible pageMode\n            const scrollTop = this.pageMode ? window.pageYOffset : this.$refs.vb.scrollTop;\n            // use requestAnimationFrame to ensure smooth scrolling visual effects\n            window.requestAnimationFrame(\n                () => {\n                    this.updateVb(scrollTop);\n                }\n            );\n        },\n        binarySearchLowerBound(s, arr) {\n            // used to search the lower bound in-viewport index for data array\n            // when height is not fixed\n            let lo = 0;\n            let hi = arr.length - 1;\n            let mid;\n            while(lo <= hi) {\n                // integer division\n                mid = ~~((hi + lo) / 2);\n                if (arr[mid] > s) {\n                    if (mid === 0) {\n                        // start position less than the smallest element in arr\n                        return 0;\n                    } else {\n                        hi = mid - 1;\n                    }\n                } else if (arr[mid] < s) {\n                    if (mid + 1 < arr.length) {\n                        if (arr[mid + 1] > s) {\n                            return mid;\n                        } else {\n                            // normal flow\n                            lo = mid + 1;\n                        }\n                    } else {\n                        // not a valid start position\n                        // start position > total height\n                        return -1;\n                    }\n                } else {\n                    // only return the matched lower bound index\n                    // may be modified later for smooth\n                    return mid;\n                }\n            }\n        },\n        binarySearchUpperBound(e, arr) {\n            // used to search the upper bound in-viewport index for data array\n            // when height is not fixed\n            let lo = 0;\n            let hi = arr.length - 1;\n            let mid;\n            while(lo <= hi) {\n                mid = ~~((hi + lo) / 2);\n                if (arr[mid] > e) {\n                    if (mid > 0) {\n                        if (arr[mid - 1] < e) {\n                            return mid;\n                        } else {\n                            // normal flow\n                            hi = mid - 1;\n                        }\n                    } else {\n                        // not a valid end position\n                        // end position < view port start position\n                        return -1;\n                    }\n                } else if (arr[mid] < e) {\n                    if (mid === arr.length - 1) {\n                        // end position greater than the biggest element in arr\n                        return arr.length - 1;\n                    } else {\n                        lo = mid + 1;\n                    }\n                } else {\n                    // lower bound should return previous block\n                    // the slice func handles the index offset issue\n                    return mid;\n                }\n            }\n        },\n        fixedBlockHeightLowerBound(s, fixedBlockHeight) {\n            // used to compute the lower bound in-viewport index for data array\n            // when in fixed height mode\n            const sAdjusted = this.pageMode ? s - this.$refs.vb.offsetTop : s;\n            const computedStartIndex = ~~(sAdjusted / fixedBlockHeight);\n            return computedStartIndex >= 0 ? computedStartIndex : 0;\n        },\n        fixedBlockHeightUpperBound(e, fixedBlockHeight) {\n            // used to compute the upper bound in-viewport index for data array\n            // when in fixed height mode\n            const eAdjusted = this.pageMode ? e - this.$refs.vb.offsetTop : e;\n            const compuedEndIndex = Math.ceil(eAdjusted / fixedBlockHeight);\n            return compuedEndIndex <= this.data.length ? compuedEndIndex : this.data.length;\n        },\n        findBlocksInViewport(s, e, heightArr, blockArr) {\n            if (s < e) {\n                const lo = this.fixedBlockHeight ? \n                           this.fixedBlockHeightLowerBound(s, this.fixedBlockHeight) :\n                           this.binarySearchLowerBound(s, heightArr);\n                const hi = this.fixedBlockHeight ? \n                           this.fixedBlockHeightUpperBound(e, this.fixedBlockHeight) :\n                           this.binarySearchUpperBound(e, heightArr);\n\n                var vbOffset = this.pageMode ? this.$refs.vb.offsetTop : 0;\n                // set top spacer\n                if(this.fixedBlockHeight) {\n                    this.offsetTop = lo >= 0 ? lo * this.fixedBlockHeight : 0;\n                } else {\n                    this.offsetTop = lo >= 0 ? heightArr[lo] - vbOffset : 0;\n                }\n                // set bot spacer\n                if (this.fixedBlockHeight) {\n                    this.offsetBot = hi >= 0 ? (blockArr.length - hi ) * this.fixedBlockHeight : 0;\n                } else {\n                    this.offsetBot = hi >= 0 ? heightArr[heightArr.length - 1] - heightArr[hi] : 0;\n                }\n                // return the sliced the data array\n                return blockArr.slice(lo, hi);;\n            } else {\n                this.offsetTop = 0;\n                this.offsetBot = 0;\n                return [];\n            }\n        },\n        updateVb(scrollTop) {\n            // compute the viewport start position and end position based on the scrollTop value\n            const viewportHeight = this.pageMode ? window.innerHeight : this.height;\n            this.viewportBegin = scrollTop;\n            this.viewportEnd = scrollTop + viewportHeight;\n            this.renderList = this.findBlocksInViewport(this.viewportBegin, this.viewportEnd, this.transformedData, this.data);\n        }\n    },\n    computed: {\n        containerStyle() {\n            return {\n                ...(!this.pageMode && {height: `${this.height}px`}),\n                ...(!this.pageMode && {'overflow-y' : 'scroll'})\n            }\n        }\n    }\n}\n</script>","/* globals __VUE_SSR_CONTEXT__ */\n\n// IMPORTANT: Do NOT use ES2015 features in this file (except for modules).\n// This module is a runtime utility for cleaner component module output and will\n// be included in the final webpack user bundle.\n\nexport default function normalizeComponent (\n  scriptExports,\n  render,\n  staticRenderFns,\n  functionalTemplate,\n  injectStyles,\n  scopeId,\n  moduleIdentifier, /* server only */\n  shadowMode /* vue-cli only */\n) {\n  scriptExports = scriptExports || {}\n\n  // ES6 modules interop\n  var type = typeof scriptExports.default\n  if (type === 'object' || type === 'function') {\n    scriptExports = scriptExports.default\n  }\n\n  // Vue.extend constructor export interop\n  var options = typeof scriptExports === 'function'\n    ? scriptExports.options\n    : scriptExports\n\n  // render functions\n  if (render) {\n    options.render = render\n    options.staticRenderFns = staticRenderFns\n    options._compiled = true\n  }\n\n  // functional template\n  if (functionalTemplate) {\n    options.functional = true\n  }\n\n  // scopedId\n  if (scopeId) {\n    options._scopeId = scopeId\n  }\n\n  var hook\n  if (moduleIdentifier) { // server build\n    hook = function (context) {\n      // 2.3 injection\n      context =\n        context || // cached call\n        (this.$vnode && this.$vnode.ssrContext) || // stateful\n        (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext) // functional\n      // 2.2 with runInNewContext: true\n      if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {\n        context = __VUE_SSR_CONTEXT__\n      }\n      // inject component styles\n      if (injectStyles) {\n        injectStyles.call(this, context)\n      }\n      // register component module identifier for async chunk inferrence\n      if (context && context._registeredComponents) {\n        context._registeredComponents.add(moduleIdentifier)\n      }\n    }\n    // used by ssr in case component is cached and beforeCreate\n    // never gets called\n    options._ssrRegister = hook\n  } else if (injectStyles) {\n    hook = shadowMode\n      ? function () { injectStyles.call(this, this.$root.$options.shadowRoot) }\n      : injectStyles\n  }\n\n  if (hook) {\n    if (options.functional) {\n      // for template-only hot-reload because in that case the render fn doesn't\n      // go through the normalizer\n      options._injectStyles = hook\n      // register for functioal component in vue file\n      var originalRender = options.render\n      options.render = function renderWithStyleInjection (h, context) {\n        hook.call(context)\n        return originalRender(h, context)\n      }\n    } else {\n      // inject component registration as beforeCreate hook\n      var existing = options.beforeCreate\n      options.beforeCreate = existing\n        ? [].concat(existing, hook)\n        : [hook]\n    }\n  }\n\n  return {\n    exports: scriptExports,\n    options: options\n  }\n}\n","var render = function () {var _vm=this;var _h=_vm.$createElement;var _c=_vm._self._c||_h;return _c('div',_vm._g({ref:\"vb\",style:(_vm.containerStyle)},_vm.pageMode ? {} : {scroll: _vm.handleScroll}),[_c('div',{style:({height: (_vm.offsetTop + \"px\")})}),_vm._v(\" \"),_vm._l((_vm.renderList),function(item){return _c('div',{key:(\"\" + (item.id)),style:({height: ((_vm.fixedBlockHeight ? _vm.fixedBlockHeight : item.height) + \"px\")})},[_vm._t(\"default\",null,{data:item})],2)}),_vm._v(\" \"),_c('div',{style:({height: (_vm.offsetBot + \"px\")})})],2)}\nvar staticRenderFns = []\nexport { render, staticRenderFns }","/* script */\nexport * from \"!!babel-loader!../node_modules/vue-loader/lib/selector?type=script&index=0!./VirtualBlock.vue\"\nimport __vue_script__ from \"!!babel-loader!../node_modules/vue-loader/lib/selector?type=script&index=0!./VirtualBlock.vue\"\n/* template */\nimport {render as __vue_render__, staticRenderFns as __vue_static_render_fns__} from \"!!../node_modules/vue-loader/lib/template-compiler/index?{\\\"id\\\":\\\"data-v-778963e1\\\",\\\"hasScoped\\\":false,\\\"optionsId\\\":\\\"0\\\",\\\"buble\\\":{\\\"transforms\\\":{}}}!../node_modules/vue-loader/lib/selector?type=template&index=0!./VirtualBlock.vue\"\n/* template functional */\nvar __vue_template_functional__ = false\n/* styles */\nvar __vue_styles__ = null\n/* scopeId */\nvar __vue_scopeId__ = null\n/* moduleIdentifier (server only) */\nvar __vue_module_identifier__ = null\nimport normalizeComponent from \"!../node_modules/vue-loader/lib/runtime/component-normalizer\"\nvar Component = normalizeComponent(\n  __vue_script__,\n  __vue_render__,\n  __vue_static_render_fns__,\n  __vue_template_functional__,\n  __vue_styles__,\n  __vue_scopeId__,\n  __vue_module_identifier__\n)\n\nexport default Component.exports\n","import VirtualBlock from './VirtualBlock.vue';\n\nconst plugin = {\n    install(Vue, options) {\n        Vue.component(\"VirtualBlock\", VirtualBlock);\n    }\n}\n\nexport default plugin;"],"sourceRoot":""}